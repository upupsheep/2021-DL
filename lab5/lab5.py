from __future__ import unicode_literals, print_function, division
from tqdm import tqdm
from torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu
from os import system
import numpy as np
import matplotlib.ticker as ticker
from io import open
import unicodedata
from string import ascii_lowercase
import string
import re
import random
import time
import math
import torch
from torch.utils import data
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')

"""==============================================================================
The sample.py includes the following template functions:
1. Encoder, decoder
2. Training function
3. BLEU-4 score function
You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.
1. The reparameterization trick
2. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
3. Output your results (BLEU-4 score, words)
4. Plot loss/score
5. Load/save weights
There are some useful tips listed in the lab assignment.
You should check them before starting your lab.
================================================================================"""

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
SOS_token = 0
EOS_token = 1
PAD_token = 2
#----------Hyper Parameters----------#
hidden_size = 256
vae_hidden_size = 32
# The number of vocabulary
vocab_size = 29
MAX_LENGTH = 10
teacher_forcing_ratio = 0.8
empty_input_ratio = 0.1
KLD_weight = 0.0
LR = 0.005

# The target word
reference = 'accessed'
# The word generated by your model
output = 'access'

# compute BLEU-4 score


class build_index(torch.utils.data.Dataset):
    def __init__(self, f_name):
        self.char_to_idx = dict()
        self.idx_to_char = dict()
        self.char_to_idx['SOS'] = 0
        self.char_to_idx['EOF'] = 1
        self.char_to_idx['PAD'] = 2
        self.idx_to_char[0] = 'SOS'
        self.idx_to_char[1] = 'EOF'
        self.idx_to_char[2] = 'PAD'

        for idx, c in enumerate(ascii_lowercase):
            self.char_to_idx[c] = idx + 3
            self.idx_to_char[idx + 3] = c

        if f_name is None:
            self.max_len = 16
            return

        f = open(f_name, "r")
        # 0 for simple present, 1 for third person, 2 for present progressing, 3 for simple past
        self.vocs = []
        self.sp_vocs = []
        self.input_labels = []
        self.output_labels = []
        self.max_len = 0

        for line in f:
            split_voc = line[:-1].split(' ')
            indices = []
            for v in split_voc:
                if len(v) > self.max_len:
                    self.max_len = len(v)
                indices.append(self.seq_to_idx(v))
            for i in range(4):
                self.sp_vocs.append(indices[i])
                self.input_labels.append(i)
                self.vocs.append(indices[i])
                self.output_labels.append(i)

        # sort according to sequence character length
        # self.sp_vocs, self.input_labels, self.vocs, self.output_labels = zip(*sorted(zip(self.sp_vocs, self.input_labels, self.vocs, self.output_labels), key=lambda seqs:len(seqs[0]), reverse=True))
        # self.sp_vocs, self.input_labels, self.vocs, self.output_labels = list(self.sp_vocs), list(self.input_labels), list(self.vocs), list(self.output_labels)
        self.sp_vocs_len = [len(s) for s in self.sp_vocs]
        self.max_len += 1  # add eof

        for i in range(len(self.sp_vocs)):
            self.sp_vocs[i] = self.do_padding(self.sp_vocs[i], self.max_len)
            self.vocs[i] = self.do_padding(self.vocs[i], self.max_len)

        self.input_labels = self.one_hot(
            self.input_labels, max(self.input_labels))
        self.output_labels = self.one_hot(
            self.output_labels, max(self.output_labels))

        self.sp_vocs = torch.LongTensor(self.sp_vocs)
        self.sp_vocs_len = torch.LongTensor(self.sp_vocs_len)
        self.input_labels = torch.FloatTensor(self.input_labels)
        self.output_labels = torch.FloatTensor(self.output_labels)
        self.vocs = torch.LongTensor(self.vocs)

        p = [x for x in range(len(self.sp_vocs))]
        random.shuffle(p)
        self.sp_vocs, self.input_labels, self.vocs, self.output_labels = self.sp_vocs[
            p], self.input_labels[p], self.vocs[p], self.output_labels[p]

    def __len__(self):
        return len(self.vocs)

    def __getitem__(self, idx):
        return self.sp_vocs[idx], self.sp_vocs_len[idx], self.input_labels[idx], self.vocs[idx], self.output_labels[idx]

    def seq_to_idx(self, seq):
        indices = []
        for c in seq:
            indices.append(self.char_to_idx[c])
        indices.append(self.char_to_idx['EOF'])

        return indices

    def idx_to_seq(self, indices):
        seq = []
        for idx in indices:
            if self.idx_to_char[idx] == 'EOF':
                break
            seq.append(self.idx_to_char[idx])

        return seq

    def idx_to_word(self, indices):
        seq = ""
        for idx in indices:
            if self.idx_to_char[idx] == 'EOF':
                break
            seq += self.idx_to_char[idx]

        return seq

    def do_padding(self, seq, max_len):
        paddings = (max_len - len(seq))

        if paddings > 0:
            seq.extend([self.char_to_idx['PAD']] * paddings)
        return seq

    def one_hot(self, idx, n):
        cs = []
        n += 1
        for i in idx:
            c = [0.0] * n
            c[i] = 1.0
            cs.append(c)
        return cs

    def get_test(self):
        raw_input_words = ["abandon", "abet", "begin", "expend", "sent",
                           "split", "flared", "functioning", "functioning", "healing"]
        raw_output_words = ["abandoned", "abetting", "begins", "expends",
                            "sends", "splitting", "flare", "function", "functioned", "heals"]
        input_words = []
        output_words = []
        input_labels = [0, 0, 0, 0, 3, 0, 3, 2, 2, 2]
        output_labels = [3, 2, 1, 1, 1, 2, 0, 0, 3, 1]

        raw_input_words, input_labels, raw_output_words, output_labels = zip(
            *sorted(zip(raw_input_words, input_labels, raw_output_words, output_labels), key=lambda seqs: len(seqs[0]), reverse=True))
        raw_input_words, input_labels, raw_output_words, output_labels = list(
            raw_input_words), list(input_labels), list(raw_output_words), list(output_labels)
        input_vocs_len = [len(s) for s in raw_input_words]

        for i in range(len(raw_input_words)):
            iw = [s for s in raw_input_words[i]]
            ow = [s for s in raw_output_words[i]]
            input_words.append(self.seq_to_idx(iw))
            output_words.append(self.seq_to_idx(ow))

        for i in range(len(input_words)):
            input_words[i] = self.do_padding(input_words[i], self.max_len)
            output_words[i] = self.do_padding(output_words[i], self.max_len)

        input_labels = self.one_hot(input_labels, max(input_labels))
        output_labels = self.one_hot(output_labels, max(output_labels))

        input_words = torch.LongTensor(input_words)
        input_vocs_len = torch.LongTensor(input_vocs_len)
        input_labels = torch.FloatTensor(input_labels)
        output_labels = torch.FloatTensor(output_labels)
        output_words = torch.LongTensor(output_words)

        return input_words, input_labels, input_vocs_len, output_words, output_labels


def compute_bleu(reference, output):
    cc = SmoothingFunction()
    return sentence_bleu(reference, output, weights=(1.0, 0.0, 0.0, 0.0), smoothing_function=cc.method1)


class VAE(nn.Module):
    def __init__(self, hidden, vae_hidden, add_label_hidden):
        super(VAE, self).__init__()
        self.fc1 = nn.Linear(hidden, vae_hidden)
        self.fc2 = nn.Linear(hidden, vae_hidden)
        self.fc3 = nn.Linear(add_label_hidden, hidden)

    def forward(self, x, labels):
        mu = self.fc1(x)
        logvar = self.fc2(x)
        z = self.reparameterize(mu, logvar)
        labels = labels.unsqueeze(0)
        z = torch.cat([z, labels], dim=2)
        z = self.fc3(z)

        return z, mu, logvar

    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5*logvar)
        eps = torch.randn_like(std)
        return mu + eps*std

# Encoder


class EncoderRNN(nn.Module):
    def __init__(self, input_size, hidden_size):
        super(EncoderRNN, self).__init__()
        self.hidden_size = hidden_size
        self.embedding = nn.Embedding(input_size, hidden_size)
        self.gru = nn.GRU(hidden_size, hidden_size)

    # input_lengths = length of original input size without padding
    # pack_padded_sequence & pad_packed_sequence: process variable input length
    def forward(self, input, input_lengths, hidden):
        embedded = self.embedding(input)
        packed = pack_padded_sequence(
            embedded, input_lengths, batch_first=True)
        packed_outputs, hidden = self.gru(packed, hidden)
        outputs, output_lengths = pad_packed_sequence(
            packed_outputs, batch_first=True)

        return outputs, hidden

# Decoder


class DecoderRNN(nn.Module):
    def __init__(self, hidden_size, output_size):
        super(DecoderRNN, self).__init__()
        self.hidden_size = hidden_size
        self.embedding = nn.Embedding(output_size, hidden_size)
        self.gru = nn.GRU(hidden_size, hidden_size)
        self.out = nn.Linear(hidden_size, output_size)
        self.softmax = nn.LogSoftmax(dim=1)

    def forward(self, input, hidden):
        batch_size = input.size(0)
        output = self.embedding(input).view(-1, batch_size, self.hidden_size)
        rnn_output, hidden = self.gru(output, hidden)  # S = T(1) x B x H
        rnn_output = rnn_output.squeeze(0)  # squeeze the time dimension
        output = self.out(rnn_output)
        output = self.softmax(output)

        return output, hidden


def loss_fn(recon_x, x, mean, log_var, criterion, KLD_weight):
    log_var = log_var.squeeze(0)
    mean = mean.squeeze(0)
    CE = criterion(recon_x, x)
    KLD = -0.5 * torch.sum(1 + log_var - mean.pow(2) - log_var.exp())

    return (CE + KLD * KLD_weight) / x.size(0), (CE) / x.size(0),  KLD / x.size(0)


def train(input_tensor, input_lengths, input_labels, target_tensor, output_labels, encoder, decoder, encoder_optimizer, decoder_optimizer, vae, vae_optimizer, criterion, is_train, teacher_forcing_ratio, KLD_weight, max_length=MAX_LENGTH):

    encoder_hidden = torch.zeros(
        input_labels.size(0), hidden_size - 4).to(device)
    encoder_hidden = torch.cat([encoder_hidden, input_labels], dim=1)
    encoder_hidden = encoder_hidden.unsqueeze(0)
    if is_train:
        encoder_optimizer.zero_grad()
        decoder_optimizer.zero_grad()
        vae_optimizer.zero_grad()

    target_length = target_tensor.size(1)

    encoder_outputs = torch.zeros(
        max_length, encoder.hidden_size, device=device)

    #----------sequence to sequence part for encoder----------#
    encoder_output, encoder_hidden = encoder(
        input_tensor, input_lengths, encoder_hidden)
    encoder_hidden, mu, logvar = vae(encoder_hidden, output_labels)

    decoder_input = torch.tensor(
        [[SOS_token] * len(input_lengths)], dtype=torch.long, device=device).view(-1, 1)
    decoder_hidden = encoder_hidden  # context vector
    use_teacher_forcing = True if random.random() < teacher_forcing_ratio else False
    if not is_train:
        use_teacher_forcing = False
    #----------sequence to sequence part for decoder----------#
    decoder_all_output = []
    loss = 0
    ce_losses = 0
    kl_losses = 0

    if use_teacher_forcing:
        # Teacher forcing: Feed the target as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden = decoder(
                decoder_input, decoder_hidden)
            if is_train:
                all_loss, ce_loss, kl_loss = loss_fn(
                    decoder_output, target_tensor[:, di], mu, logvar, criterion, KLD_weight)
                loss += all_loss
                with torch.no_grad():
                    ce_losses += ce_loss
                    kl_losses += kl_loss

            topv, topi = decoder_output.topk(1)
            decoder_all_output.append(topi.view(-1, 1).detach()[:, 0])

            if topi.view(-1, 1).detach()[:, 0].item() < 0 or topi.view(-1, 1).detach()[:, 0].item() > 29:
                print(decoder_input[:, 0].item())

            decoder_input = target_tensor[:, di].view(-1, 1)  # Teacher forcing
    else:
        # Without teacher forcing: use its own predictions as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden = decoder(
                decoder_input, decoder_hidden)
            topv, topi = decoder_output.topk(1)
            decoder_input = topi.view(-1, 1).detach()
            decoder_all_output.append(decoder_input[:, 0])
            if is_train:
                all_loss, ce_loss, kl_loss = loss_fn(
                    decoder_output, target_tensor[:, di], mu, logvar, criterion, KLD_weight)
                loss += all_loss
                with torch.no_grad():
                    ce_losses += ce_loss
                    kl_losses += kl_loss

    if is_train:
        loss.backward()
        encoder_optimizer.step()
        decoder_optimizer.step()
        vae_optimizer.step()
    decoder_all_output = torch.stack(decoder_all_output).transpose(1, 0)

    if is_train:
        return loss.item(), decoder_all_output, ce_losses, kl_losses
    else:
        return loss, decoder_all_output, ce_losses, kl_losses


def asMinutes(s):
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)


def timeSince(since, percent):
    now = time.time()
    s = now - since
    es = s / (percent)
    rs = es - s
    return '%s (- %s)' % (asMinutes(s), asMinutes(rs))


def trainIters(encoder, decoder, vae, n_iters, learning_rate=0.01, teacher_forcing_ratio=0.8, KLD_weight=0.0, print_every=10, plot_every=100):
    torch.backends.cudnn.benchmark = True
    start = time.time()
    plot_losses = []
    print_loss_total = 0  # Reset every print_every
    plot_loss_total = 0  # Reset every plot_every

    encoder_optimizer = optim.SGD(encoder.parameters(), lr=learning_rate)
    decoder_optimizer = optim.SGD(decoder.parameters(), lr=learning_rate)
    vae_optimizer = optim.SGD(vae.parameters(), lr=learning_rate)

    builder = build_index("./data/train.txt")
    MAX_LENGTH = builder.max_len
    batch_size = len(builder.sp_vocs_len)
    criterion = nn.NLLLoss(ignore_index=PAD_token, reduction='mean')

    train_loader = torch.utils.data.DataLoader(
        builder,
        batch_size=1,
        shuffle=True,
        drop_last=False,
        pin_memory=True,
        num_workers=4,
    )

    test_input_words, test_input_labels, test_input_len, test_output_words, test_output_labels = builder.get_test()
    test_input_words = test_input_words.to(device, dtype=torch.long)
    test_input_len = test_input_len.to(device, dtype=torch.long)
    test_input_labels = test_input_labels.to(device, dtype=torch.float)
    test_output_words = test_output_words.to(device, dtype=torch.long)
    test_output_labels = test_output_labels.to(device, dtype=torch.float)

    encoder.train()
    decoder.train()
    vae.train()

    ce_losses = []
    kl_losses = []
    outputs = []
    bleu_scores = []
    teacher_forcing_ratio_acc = []
    KLD_weight_acc = []
    for iter in tqdm(range(n_iters)):
        ce_loss_acc = 0
        kl_loss_acc = 0
        bleu_score = 0

        for input_tensor, input_len, input_labels, target_tensor, output_labels in tqdm(train_loader, leave=False):
            input_tensor = input_tensor.to(device, dtype=torch.long)
            input_len = input_len.to(device, dtype=torch.long)
            input_labels = input_labels.to(device, dtype=torch.float)
            target_tensor = target_tensor.to(device, dtype=torch.long)
            output_labels = output_labels.to(device, dtype=torch.float)

            loss, output, ce_loss, kl_loss = train(input_tensor, input_len, input_labels, target_tensor, output_labels, encoder,
                                                   decoder, encoder_optimizer, decoder_optimizer, vae, vae_optimizer, criterion, True, teacher_forcing_ratio, KLD_weight)
            ce_loss_acc += ce_loss
            kl_loss_acc += kl_loss
            print_loss_total += loss
            plot_loss_total += loss

        ce_losses.append(ce_loss_acc.item() / batch_size)
        kl_losses.append(kl_loss_acc.item() / batch_size)
        teacher_forcing_ratio_acc.append(teacher_forcing_ratio)
        KLD_weight_acc.append(KLD_weight)

        encoder.eval()
        decoder.eval()
        vae.eval()

        loss_test, output_test, ce_loss_test, kl_loss_test = train(test_input_words, test_input_len, test_input_labels, test_output_words, test_output_labels, encoder,
                                                                   decoder, encoder_optimizer, decoder_optimizer, vae, vae_optimizer, criterion, False, teacher_forcing_ratio, KLD_weight)
        # output_test = run_test(test_input_words, test_input_len, test_input_labels, test_output_words, test_output_labels, encoder, decoder, vae)
        for r, o in zip(test_output_words, output_test):
            r = r.tolist()
            o = o.tolist()
            r = builder.idx_to_seq(r)
            o = builder.idx_to_seq(o)
            print(r)
            print(o)
            print("---")
            bleu_score += compute_bleu([r], o)
        bleu_score = bleu_score / 10
        bleu_scores.append(bleu_score)

        encoder.train()
        decoder.train()
        vae.train()

        if iter % print_every == 0:
            for i in range(1):
                print("label:  ", input_labels[i].cpu(
                ).argmax(), output_labels[i].cpu().argmax())
                print("input:  ", builder.idx_to_seq(
                    input_tensor[i].cpu().numpy()))
                print("answer: ", builder.idx_to_seq(
                    target_tensor[i].cpu().numpy()))
                print("output: ", builder.idx_to_seq(output[i].tolist()))
                print("---")
            print("bleu for test: ", bleu_score)
            print(iter, ":", print_loss_total / batch_size)
            print("teacher_forcing_ratio: ", teacher_forcing_ratio)
            print("KLD weight: ", KLD_weight)
            print("kl_loss: ", kl_loss_acc.item() / batch_size)
            print("ce_loss: ", ce_loss_acc.item() / batch_size)
            torch.save(bleu_scores, str(iter) + '_bleu_losses.pt')
            torch.save(ce_losses, str(iter) + '_ce_losses.pt')
            torch.save(kl_losses, str(iter) + '_kl_losses.pt')
            torch.save(teacher_forcing_ratio_acc, str(
                iter) + '_teacher_forcing_ratio_acc.pt')
            torch.save(KLD_weight_acc, str(iter) + '_kld_weight_acc.pt')
            torch.save(encoder.state_dict(), "./" +
                       "encoder_" + str(iter) + ".pth")
            torch.save(decoder.state_dict(), "./" +
                       "decoder_" + str(iter) + ".pth")
            torch.save(vae.state_dict(), "./" + "vae_" + str(iter) + ".pth")

            print_loss_avg = print_loss_total / print_every
            print_loss_total = 0

        if bleu_score > 0.8:
            teacher_forcing_ratio -= 0.01
            teacher_forcing_ratio = max(teacher_forcing_ratio, 0.0)
            KLD_weight += 0.01
            KLD_weight = min(KLD_weight, 1.0)


def self_defined_test(encoder, decoder, vae, test_seq, input_labels, output_labels):
    encoder.eval()
    decoder.eval()
    vae.eval()

    builder = build_index(None)
    test_input_words = []
    for seq in test_seq:
        test_input_words.append(builder.seq_to_idx(seq))
    test_input_len = [len(s) for s in test_input_words]

    test_input_labels = []
    test_output_labels = []
    for i in len(input_labels):
        input_c = [0.0] * n
        output_c = [0.0] * n
        input_c[i] = 1.0
        output_c[i] = 1.0
        test_input_labels.append(input_c)
        test_output_labels.append(output_c)

    loss_test, output_test, ce_loss_test, kl_loss_test = train(test_input_words, test_input_len, test_input_labels, None, test_output_labels, encoder,
                                                               decoder, None, None, vae, None, None, False, teacher_forcing_ratio=0.0, KLD_weight=1.0)


encoder = EncoderRNN(vocab_size, hidden_size).to(device)
decoder = DecoderRNN(hidden_size, vocab_size).to(
    device)  # vocab_size = sos, eof, pad, a-z
vae = VAE(hidden_size, vae_hidden_size, vae_hidden_size + 4).to(device)

training = True
teacher_forcing_ratio = 0.8
KLD_weight = 0.0
if training:
    trainIters(encoder, decoder, vae, 100, LR, teacher_forcing_ratio,
               KLD_weight, print_every=1, plot_every=100)
else:
    encoder.load_state_dict(torch.load("./encoder_9.pth"))
    decoder.load_state_dict(torch.load("./decoder_9.pth"))
    vae.load_state_dict(torch.load("./vae_9.pth"))

    encoder.eval()
    decoder.eval()
    vae.eval()

    builder = build_index(None)
    test_input_words, test_input_labels, test_input_len, test_output_words, test_output_labels = builder.get_test()
    test_input_words = test_input_words.to(device, dtype=torch.long)
    test_input_len = test_input_len.to(device, dtype=torch.long)
    test_input_labels = test_input_labels.to(device, dtype=torch.float)
    test_output_words = test_output_words.to(device, dtype=torch.long)
    test_output_labels = test_output_labels.to(device, dtype=torch.float)

    loss_test, output_test, ce_loss_test, kl_loss_test = train(test_input_words, test_input_len, test_input_labels, test_output_words, test_output_labels, encoder,
                                                               decoder, None, None, vae, None, None, False, teacher_forcing_ratio, KLD_weight)
    bleu_score = 0
    for r, o in zip(test_output_words, output_test):
        r = r.tolist()
        o = o.tolist()
        r = builder.idx_to_seq(r)
        o = builder.idx_to_seq(o)
        b = compute_bleu([r], o)
        bleu_score += b
        print(r)
        print(o)
        print("---")
    print("avg: ", bleu_score / len(output_test))

    encoder.load_state_dict(torch.load("./encoder_72.pth"))
    decoder.load_state_dict(torch.load("./decoder_72.pth"))
    vae.load_state_dict(torch.load("./vae_72.pth"))
    encoder.eval()
    decoder.eval()
    vae.eval()

    labels = [0, 1, 2, 3]
    one_hot_labels = []
    for i in labels:
        c = [0.0] * 4
        c[i] = 1.0
        one_hot_labels.append(c)

    one_hot_labels = torch.FloatTensor(one_hot_labels)
    one_hot_labels = one_hot_labels.to(device, dtype=torch.float)

    zeros = torch.zeros(1, 1, vae_hidden_size).to(device)
    for i in range(3):
        z = torch.randn_like(zeros)
        target_length = 16
        for i in range(len(one_hot_labels)):
            o = torch.cat([z, one_hot_labels[i].view(1, 1, -1)], dim=2)
            o = vae.fc3(o)

            decoder_input = torch.tensor(
                [[SOS_token]], dtype=torch.long, device=device).view(-1, 1)
            decoder_hidden = o
            decoder_all_output = []
            for di in range(target_length):
                decoder_output, decoder_hidden = decoder(
                    decoder_input, decoder_hidden)
                topv, topi = decoder_output.topk(1)
                decoder_input = topi.view(-1, 1).detach()
                decoder_all_output.append(decoder_input[:, 0])

            decoder_all_output = torch.stack(
                decoder_all_output).transpose(1, 0)
            print(builder.idx_to_seq(decoder_all_output.cpu().tolist()[0]))
        print("-" * 20)
